# Event

## Transaction 구현이 필요한 곳을 찾아보자 Case 1 - 머니 충전

- 머니 충전 시의 트랜잭션 작업이 필요합니다.

1. 회원확인 (To Membership) (Read)
   1. 실패 시, 종료
2. 펌뱅킹 요청 (To Banking) (Write)
   1. 고객 연결 계좌 -> 페이 법인 계좌 이체 요청
3. 성공 후, Money Service DB Update (Write)
   1. 특정 고객의 잔액을 Update 해야 함
'펌뱅킹 요청은 성공 했지만 머니 DB에 업데이트가 불가능 할 경우' -> 출금은 되지만 머니 잔액이 증액 되지 않을 것임

(Money DB가 문제가 생겼을 경우)
**재시도를 통해서 해결** 
- 머니 서비스가 성공 응답을 받을 때까지 지속적으로 요청을 진행하여야 함.
  - 요청에 대한 부하가 많이 받아진다면? (SPOF)       
  - DLQ (Dead Letter Queue)
    - 재시도 후에도 실패한 작업이 들어가는 큐
    - Timeout 처럼 실패 시키는 것임

-> 비즈니스가 너무 위험성이 높기 때문에 이런식으로 구현하면 금감원에 끌려 갈 수도 있음

**DB에 실행 상태를 기록**
- RDB에 상태 기록을 통해서 트랜잭션을 구현
  - RDB 부하가 많음
  - RDB는 비용 소모가 매우 큼
-> 적절하지 않다.

**결론 : 트랜잭션의 구현이 필수적이다.**

## Transaction 구현이 필요한 곳을 찾아보자 Case 2 - 송금

1. 회원 확인 (To Membership) (Read)
   1. 실패 시, 종료
2. 머니 잔액 확인 (To Money) (Read)
   1. 머니 충분하면 머니 이동 요청 (To Money) Write
   2. 부족하면 뱅킹 충전 요청 (To Banking) Write
      1. 펌뱅킹 완료 후, 머니 이동 요청 (To Money) Write

'펌뱅킹은 되었지만 송금이 되지 않았을 때'
-> 출금이 되어, 머니 충전은 되었지만 외부 은행으로 송금이 실패
-> 사실상, 실패하여도 문제가 되지는 않는다. (내 돈이 사라진 것이 아니기 때문에 고객 영향도가 크지 않다고 볼 수 있습니다.)

**결론 : 트랜잭션 구현을 굳이 해야 할 필요가 없다.**